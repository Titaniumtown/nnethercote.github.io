<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides heap profiling and ad hoc profiling capabilities to Rust programs, similar to those provided by DHAT."><meta name="keywords" content="rust, rustlang, rust-lang, dhat"><title>dhat - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../dhat/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate dhat</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.3.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all dhat's items</p></a><div class="block items"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="dhat" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">dhat</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/dhat/lib.rs.html#1-1925" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides heap profiling and ad hoc profiling capabilities to
Rust programs, similar to those provided by <a href="https://www.valgrind.org/docs/manual/dh-manual.html">DHAT</a>.</p>
<p>The heap profiling works by using a global allocator that wraps the system
allocator, tracks all heap allocations, and on program exit writes data to
file so it can be viewed with DHAT’s viewer. This corresponds to DHAT’s
<code>--mode=heap</code> mode.</p>
<p>The ad hoc profiling is via a second mode of operation, where ad hoc events
can be manually inserted into a Rust program for aggregation and viewing.
This corresponds to DHAT’s <code>--mode=ad-hoc</code> mode.</p>
<p><code>dhat</code> also supports <em>heap usage testing</em>, where you can write tests and
then check that they allocated as much heap memory as you expected. This
can be useful for performance-sensitive code.</p>
<h2 id="motivation" class="section-header"><a href="#motivation">Motivation</a></h2>
<p>DHAT is a powerful heap profiler that comes with Valgrind. This crate is a
related but alternative choice for heap profiling Rust programs. DHAT and
this crate have the following differences.</p>
<ul>
<li>This crate works on any platform, while DHAT only works on some platforms
(Linux, mostly). (Note that DHAT’s viewer is just HTML+JS+CSS and should
work in any modern web browser on any platform.)</li>
<li>This crate typically causes a smaller slowdown than DHAT.</li>
<li>This crate requires some modifications to a program’s source code and
recompilation, while DHAT does not.</li>
<li>This crate cannot track memory accesses the way DHAT does, because it does
not instrument all memory loads and stores.</li>
<li>This crate does not provide profiling of copy functions such as <code>memcpy</code>
and <code>strcpy</code>, unlike DHAT.</li>
<li>The backtraces produced by this crate may be better than those produced
by DHAT.</li>
<li>DHAT measures a program’s entire execution, but this crate only measures
what happens within <code>main</code>. It will miss the small number of allocations
that occur before or after <code>main</code>, within the Rust runtime.</li>
<li>This crate enables heap usage testing.</li>
</ul>
<h2 id="configuration-profiling-and-testing" class="section-header"><a href="#configuration-profiling-and-testing">Configuration (profiling and testing)</a></h2>
<p>In your <code>Cargo.toml</code> file, as well as specifying <code>dhat</code> as a dependency,
you should enable source line debug info:</p>
<div class="example-wrap"><pre class="language-toml"><code>[profile.release]
debug = 1</code></pre></div>
<p>You should only use <code>dhat</code> in release builds. Debug builds are too slow to
be useful.</p>
<h2 id="setup-heap-profiling" class="section-header"><a href="#setup-heap-profiling">Setup (heap profiling)</a></h2>
<p>For heap profiling, enable the global allocator by adding this code to your
program:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">global_allocator</span>]</span>
<span class="kw">static</span> <span class="ident">ALLOC</span>: <span class="ident">dhat::Alloc</span> <span class="op">=</span> <span class="ident">dhat::Alloc</span>;</code></pre></div>
<p>Then add the following code to the very start of your <code>main</code> function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">_profiler</span> <span class="op">=</span> <span class="ident">dhat::Profiler::new_heap</span>();</code></pre></div>
<p>Profiling will occur during the lifetime of the <a href="struct.Profiler.html" title="Profiler"><code>Profiler</code></a> instance.</p>
<p><a href="struct.Alloc.html"><code>dhat::Alloc</code></a> is slower than the normal allocator, so it should
only be enabled while profiling.</p>
<h2 id="setup-ad-hoc-profiling" class="section-header"><a href="#setup-ad-hoc-profiling">Setup (ad hoc profiling)</a></h2>
<p><a href="https://github.com/nnethercote/counts/#ad-hoc-profiling">Ad hoc profiling</a> involves manually annotating hot code points and then
aggregating the executed annotations in some fashion.</p>
<p>To do this, add the following code to the very start of your <code>main</code>
function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">let</span> <span class="ident">_profiler</span> <span class="op">=</span> <span class="ident">dhat::Profiler::new_ad_hoc</span>();</code></pre></div>
<p>Then insert calls like this at points of interest:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">dhat::ad_hoc_event</span>(<span class="number">100</span>);</code></pre></div>
<p>For example, imagine you have a hot function that is called from many call
sites. You might want to know how often it is called and which other
functions called it the most. In that case, you would add an
<a href="fn.ad_hoc_event.html" title="ad_hoc_event"><code>ad_hoc_event</code></a> call to that function, and the data collected by this
crate and viewed with DHAT’s viewer would show you exactly what you want to
know.</p>
<p>The meaning of the integer argument to <code>ad_hoc_event</code> will depend on
exactly what you are measuring. If there is no meaningful weight to give to
an event, you can just use <code>1</code>.</p>
<h2 id="running" class="section-header"><a href="#running">Running</a></h2>
<p>For both heap profiling and ad hoc profiling, the program will run more
slowly than normal. The exact slowdown is hard to predict because it
depends greatly on the program being profiled, but it can be large. (Even
more so on Windows, because backtrace gathering can be drastically slower
on Windows than on other platforms.)</p>
<p>When the <a href="struct.Profiler.html" title="Profiler"><code>Profiler</code></a> is dropped at the end of <code>main</code>, some basic
information will be printed to <code>stderr</code>. For heap profiling it will look
like the following.</p>
<div class="example-wrap"><pre class="language-text"><code>dhat: Total:     1,256 bytes in 6 blocks
dhat: At t-gmax: 1,256 bytes in 6 blocks
dhat: At t-end:  1,256 bytes in 6 blocks
dhat: The data has been saved to dhat-heap.json, and is viewable with dhat/dh_view.html</code></pre></div>
<p>(“Blocks” is a synonym for “allocations”.)</p>
<p>For ad hoc profiling it will look like the following.</p>
<div class="example-wrap"><pre class="language-text"><code>dhat: Total:     141 units in 11 events
dhat: The data has been saved to dhat-ad-hoc.json, and is viewable with dhat/dh_view.html</code></pre></div>
<p>A file called <code>dhat-heap.json</code> (for heap profiling) or <code>dhat-ad-hoc.json</code>
(for ad hoc profiling) will be written. It can be viewed in DHAT’s viewer.</p>
<p>If you don’t see this output, it may be because your program called
<a href="https://doc.rust-lang.org/1.57.0/std/process/fn.exit.html" title="std::process::exit"><code>std::process::exit</code></a>, which exits a program without running any
destructors. To work around this, explicitly call <code>drop</code> on the
<a href="struct.Profiler.html" title="Profiler"><code>Profiler</code></a> value just before exiting.</p>
<p>When doing heap profiling, if you unexpectedly see zero allocations in the
output it may be because you forgot to set <a href="struct.Alloc.html"><code>dhat::Alloc</code></a> as the
global allocator.</p>
<p>When doing heap profiling it is recommended that the lifetime of the
<a href="struct.Profiler.html" title="Profiler"><code>Profiler</code></a> value cover all of <code>main</code>. But it is still possible for
allocations and deallocations to occur outside of its lifetime. Such cases
are handled in the following ways.</p>
<ul>
<li>Allocated before, untouched within: ignored.</li>
<li>Allocated before, freed within: ignored.</li>
<li>Allocated before, reallocated within: treated like a new allocation
within.</li>
<li>Allocated after: ignored.</li>
</ul>
<p>These cases are not ideal, but it is impossible to do better. <code>dhat</code>
deliberately provides no way to reset the heap profiling state mid-run
precisely because it leaves open the possibility of many such occurrences.</p>
<h2 id="viewing" class="section-header"><a href="#viewing">Viewing</a></h2>
<p>Open a copy of DHAT’s viewer, version 3.17 or later. There are two ways to
do this.</p>
<ul>
<li>Easier: Use the <a href="https://nnethercote.github.io/dh_view/dh_view.html">online version</a>.</li>
<li>Harder: Clone the <a href="https://www.valgrind.org/downloads/repository.html">Valgrind repository</a> with <code>git clone git://sourceware.org/git/valgrind.git</code> and open <code>dhat/dh_view.html</code>.
(There is no need to build any code in this repository.)</li>
</ul>
<p>Then click on the “Load…” button to load <code>dhat-heap.json</code> or
<code>dhat-ad-hoc.json</code>.</p>
<p>DHAT’s viewer shows a tree with nodes that look like this.</p>
<div class="example-wrap"><pre class="language-text"><code>PP 1.1/2 {
  Total:     1,024 bytes (98.46%, 14,422,535.21/s) in 1 blocks (50%, 14,084.51/s), avg size 1,024 bytes, avg lifetime 35 µs (49.3% of program duration)
  Max:       1,024 bytes in 1 blocks, avg size 1,024 bytes
  At t-gmax: 1,024 bytes (98.46%) in 1 blocks (50%), avg size 1,024 bytes
  At t-end:  1,024 bytes (100%) in 1 blocks (100%), avg size 1,024 bytes
  Allocated at {
    #1: 0x10ae8441b: &lt;alloc::alloc::Global as core::alloc::Allocator&gt;::allocate (alloc/src/alloc.rs:226:9)
    #2: 0x10ae8441b: alloc::raw_vec::RawVec&lt;T,A&gt;::allocate_in (alloc/src/raw_vec.rs:207:45)
    #3: 0x10ae8441b: alloc::raw_vec::RawVec&lt;T,A&gt;::with_capacity_in (alloc/src/raw_vec.rs:146:9)
    #4: 0x10ae8441b: alloc::vec::Vec&lt;T,A&gt;::with_capacity_in (src/vec/mod.rs:609:20)
    #5: 0x10ae8441b: alloc::vec::Vec&lt;T&gt;::with_capacity (src/vec/mod.rs:470:9)
    #6: 0x10ae8441b: std::io::buffered::bufwriter::BufWriter&lt;W&gt;::with_capacity (io/buffered/bufwriter.rs:115:33)
    #7: 0x10ae8441b: std::io::buffered::linewriter::LineWriter&lt;W&gt;::with_capacity (io/buffered/linewriter.rs:109:29)
    #8: 0x10ae8441b: std::io::buffered::linewriter::LineWriter&lt;W&gt;::new (io/buffered/linewriter.rs:89:9)
    #9: 0x10ae8441b: std::io::stdio::stdout::{{closure}} (src/io/stdio.rs:680:58)
    #10: 0x10ae8441b: std::lazy::SyncOnceCell&lt;T&gt;::get_or_init_pin::{{closure}} (std/src/lazy.rs:375:25)
    #11: 0x10ae8441b: std::sync::once::Once::call_once_force::{{closure}} (src/sync/once.rs:320:40)
    #12: 0x10aea564c: std::sync::once::Once::call_inner (src/sync/once.rs:419:21)
    #13: 0x10ae81b1b: std::sync::once::Once::call_once_force (src/sync/once.rs:320:9)
    #14: 0x10ae81b1b: std::lazy::SyncOnceCell&lt;T&gt;::get_or_init_pin (std/src/lazy.rs:374:9)
    #15: 0x10ae81b1b: std::io::stdio::stdout (src/io/stdio.rs:679:16)
    #16: 0x10ae81b1b: std::io::stdio::print_to (src/io/stdio.rs:1196:21)
    #17: 0x10ae81b1b: std::io::stdio::_print (src/io/stdio.rs:1209:5)
    #18: 0x10ae2fe20: dhatter::main (dhatter/src/main.rs:8:5)
  }
}</code></pre></div>
<p>Full details about the output are in the <a href="https://valgrind.org/docs/manual/dh-manual.html">DHAT documentation</a>. Note that
DHAT uses the word “block” as a synonym for “allocation”.</p>
<p>When heap profiling, this crate doesn’t track memory accesses (unlike DHAT)
and so the “reads” and “writes” measurements are not shown within DHAT’s
viewer, and “sort metric” views involving reads, writes, or accesses are
not available.</p>
<p>The backtraces produced by this crate are trimmed to reduce output file
sizes and improve readability in DHAT’s viewer, in the following ways.</p>
<ul>
<li>Only one allocation-related frame will be shown at the top of the
backtrace. That frame may be a function within <code>alloc::alloc</code>, a function
within this crate, or a global allocation function like <code>__rg_alloc</code>.</li>
<li>Common frames at the bottom of backtraces, below <code>main</code>, are omitted.</li>
</ul>
<p>Backtrace trimming is inexact and if the above heuristics fail more frames
will be shown. <a href="struct.ProfilerBuilder.html#method.trim" title="ProfilerBuilder::trim"><code>ProfilerBuilder::trim</code></a> allows (approximate) control of
how deep backtraces will be.</p>
<h2 id="heap-usage-testing" class="section-header"><a href="#heap-usage-testing">Heap usage testing</a></h2>
<p><code>dhat</code> lets you write tests that check that a certain piece of code does a
certain amount of heap allocation when it runs. This is sometimes called
“high water mark” testing. Sometimes it is precise (e.g. “this code should
do exactly 96 allocations” or “this code should free all allocations before
finishing”) and sometimes it is less precise (e.g. “the peak heap usage of
this code should be less than 10 MiB”).</p>
<p>Each such test needs to be in a separate integration test in your crate’s
<code>tests/</code> directory. (It cannot be within a unit test, and there cannot be
more than one heap usage test per integration test, because heap profiling
involves global state and multiple tests within the same process will
interfere with each other.)</p>
<p>Integration tests can only be used to test items from libraries, not
binaries. If you want to do heap usage testing of items from a binary, the
best approach is probably to restructure things so that most of the
functionality is in a library, and the binary is a thin wrapper around the
library.</p>
<p>Configuration of <code>Cargo.toml</code> is much the same as for the profiling use case.</p>
<p>Here is an example showing what is possible:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">global_allocator</span>]</span>
<span class="kw">static</span> <span class="ident">ALLOC</span>: <span class="ident">dhat::Alloc</span> <span class="op">=</span> <span class="ident">dhat::Alloc</span>;

<span class="attribute">#[<span class="ident">test</span>]</span>
<span class="kw">fn</span> <span class="ident">test1</span>() {
    <span class="kw">let</span> <span class="ident">_profiler</span> <span class="op">=</span> <span class="ident">dhat::ProfilerBuilder::new</span>().<span class="ident">testing</span>().<span class="ident">build</span>();

    <span class="kw">let</span> <span class="ident">_v1</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
    <span class="kw">let</span> <span class="ident">v2</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];
    <span class="ident">drop</span>(<span class="ident">v2</span>);
    <span class="kw">let</span> <span class="ident">v3</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>];
    <span class="ident">drop</span>(<span class="ident">v3</span>);

    <span class="kw">let</span> <span class="ident">stats</span> <span class="op">=</span> <span class="ident">dhat::HeapStats::get</span>();

    <span class="comment">// Three allocations were done in total.</span>
    <span class="macro">dhat::assert_eq!</span>(<span class="ident">stats</span>.<span class="ident">total_blocks</span>, <span class="number">3</span>);
    <span class="macro">dhat::assert_eq!</span>(<span class="ident">stats</span>.<span class="ident">total_bytes</span>, <span class="number">48</span>);

    <span class="comment">// At the point of peak heap size, two allocations totalling 32 bytes existed.</span>
    <span class="macro">dhat::assert_eq!</span>(<span class="ident">stats</span>.<span class="ident">max_blocks</span>, <span class="number">2</span>);
    <span class="macro">dhat::assert_eq!</span>(<span class="ident">stats</span>.<span class="ident">max_bytes</span>, <span class="number">32</span>);

    <span class="comment">// Now a single allocation remains alive.</span>
    <span class="macro">dhat::assert_eq!</span>(<span class="ident">stats</span>.<span class="ident">curr_blocks</span>, <span class="number">1</span>);
    <span class="macro">dhat::assert_eq!</span>(<span class="ident">stats</span>.<span class="ident">curr_bytes</span>, <span class="number">16</span>);
}</code></pre></div>
<p>The <a href="struct.ProfilerBuilder.html#method.testing"><code>testing</code></a> call puts the profiler into
testing mode, which allows the stats provided by <a href="struct.HeapStats.html#method.get" title="HeapStats::get"><code>HeapStats::get</code></a> to be
checked with <a href="macro.assert.html"><code>dhat::assert!</code></a> and similar assertions. These
assertions work much the same as normal assertions, except that if any of
them fail a heap profile will be saved.</p>
<p>When viewing the heap profile after a failure, the best choice of sort
metric in the viewer will depend on which stat was involved in the
assertion failure.</p>
<ul>
<li><code>total_blocks</code>: “Total (blocks)”</li>
<li><code>total_bytes</code>: “Total (bytes)”</li>
<li><code>max_blocks</code> or <code>max_bytes</code>: “At t-gmax (bytes)”</li>
<li><code>curr_blocks</code> or <code>curr_bytes</code>: “At t-end (bytes)”</li>
</ul>
<p>This should give you a good understanding of why the assertion failed.</p>
<p>Note: if you try this example test it may work in a debug build but fail in
a release build. This is because the compiler may optimize away some of the
allocations that are unused. This is a common problem for contrived
examples but less common for real tests.</p>
<h2 id="ad-hoc-usage-testing" class="section-header"><a href="#ad-hoc-usage-testing">Ad hoc usage testing</a></h2>
<p>Ad hoc usage testing is also possible. It can be used to ensure certain
code points in your program are hit a particular number of times during
execution. It works in much the same way as heap usage testing, but
<a href="struct.ProfilerBuilder.html#method.ad_hoc" title="ProfilerBuilder::ad_hoc"><code>ProfilerBuilder::ad_hoc</code></a> must be specified, and <a href="struct.AdHocStats.html#method.get" title="AdHocStats::get"><code>AdHocStats::get</code></a> is
used instead of <a href="struct.HeapStats.html#method.get" title="HeapStats::get"><code>HeapStats::get</code></a>.</p>
</div></details><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.assert.html" title="dhat::assert macro">assert</a></div><div class="item-right docblock-short"><p>Asserts that an expression is true.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.assert_eq.html" title="dhat::assert_eq macro">assert_eq</a></div><div class="item-right docblock-short"><p>Asserts that two expressions are equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.assert_ne.html" title="dhat::assert_ne macro">assert_ne</a></div><div class="item-right docblock-short"><p>Asserts that two expressions are not equal.</p>
</div></div></div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.AdHocStats.html" title="dhat::AdHocStats struct">AdHocStats</a></div><div class="item-right docblock-short"><p>Stats from ad hoc profiling.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Alloc.html" title="dhat::Alloc struct">Alloc</a></div><div class="item-right docblock-short"><p>A global allocator that tracks allocations and deallocations on behalf of
the <a href="struct.Profiler.html" title="Profiler"><code>Profiler</code></a> type.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.HeapStats.html" title="dhat::HeapStats struct">HeapStats</a></div><div class="item-right docblock-short"><p>Stats from heap profiling.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Profiler.html" title="dhat::Profiler struct">Profiler</a></div><div class="item-right docblock-short"><p>A type whose lifetime dictates the start and end of profiling.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ProfilerBuilder.html" title="dhat::ProfilerBuilder struct">ProfilerBuilder</a></div><div class="item-right docblock-short"><p>A builder for <a href="struct.Profiler.html" title="Profiler"><code>Profiler</code></a>, for cases beyond the basic ones provided by
<a href="struct.Profiler.html" title="Profiler"><code>Profiler</code></a>.</p>
</div></div></div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.ad_hoc_event.html" title="dhat::ad_hoc_event fn">ad_hoc_event</a></div><div class="item-right docblock-short"><p>Registers an event during ad hoc profiling.</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="dhat" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>